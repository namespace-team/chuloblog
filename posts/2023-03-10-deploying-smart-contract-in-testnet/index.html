<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
      Deploying smart contract in testnet
    </title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
<link type="text/css" rel="stylesheet" href="/assets/css/style.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&ffamily=Noto+Sans+Lao:wght@200&family=Raleway:wght@600&family=Roboto+Mono:wght@100&display=swap" rel="stylesheet">
<meta property="og:title" content="Blog site from web developers" />
<meta property="og:description" content="to document our progress, share oer experiences, and connect with others who share our passion for technology." />
<meta property="og:image" content="https://i.ibb.co/BrMjWsD/Screenshot-2023-03-22-at-13-11-55.png" />

<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>


  </style>
  </head>
  <body>
      <header>
        
<nav class="links">
<a href="/" class="logo">TIL</a>
  <ul>
    <li class="search">
      <form class="search" onSubmit=" lunr_search(document.getElementById('lunrsearch').value);" style="height: 100%;" method="dialog">
          <input type="text" class="form-control" id="lunrsearch" name="q" maxlength="255" value="" placeholder="Search..." style="display:flex;height: 100%;"/>
      </form>
    </li>
  </ul>
  <ul class="header-menus">
    
      <li><a href="/about" >About</a></li>
    
  </ul>
</nav>
<script>
var documents = [{
    "id": 0,
    "url": "/authors/poudelmadhav",
    "title": "Advantage of health checkup",
    "body": "Reduce Stress level &amp; helps to improve physical fitness Helps to improve well being and self-assurance Reduce health risks &amp; personal medical costs Access to health information"
    },{
    "id": 1,
    "url": "/authors/salinadangol2",
    "title": "Functional and Non-functional Testing",
    "body": "Functional Testing Functional testing is a type of testing which verifies that each function of the software application works as expected. Every functionality of the system is tested by providing appropriate input, verifying the output and comparing the actual results with the expected results. This testing involves checking of User Interface, APIs, Database, security, client/ server applications and functionality of the application. Examples of Functional Testing Types  Unit testing  Smoke testing  User Acceptance  Integration Testing  Regression testing  Non-Functional Testing Non-functional testing is a type of testing to check non-functional aspects (performance, usability, reliability, etc.) of a software application. The primary purpose of non-functional testing is to test the reading speed of the software system as per non-functional parameters. The parameters of non-functional testing are never tested before the functional testing. Examples of Non-functional Testing Types  Performance Testing  Scalability Testing  Usability Testing  Load Testing  Stress Testing  Portability Testing  Key Difference Between Functional Testing and Non Functional Testing  Functional testing verifies each function/feature of the software whereas Non Functional testing verifies non-functional aspects like performance, usability, reliability, etc.  Functional testing can be done manually whereas Non Functional testing is hard to perform manually.  Functional testing is based on customer’s requirements whereas Non Functional testing is based on customer’s expectations.  A Functional Testing example is to check the login functionality whereas a Non Functional testing example is to check the dashboard should load in 2 seconds."
    },{
    "id": 2,
    "url": "/authors/salinadangol2",
    "title": "Yoga in Daily Life",
    "body": "Yoga is not a religion, it is a way of living that aims towards a healthy mind in a healthy body. According to the National Institutes of Health, scientific evidence shows that yoga supports stress management, mental health, mindfulness, healthy eating, weight loss and quality sleep. I took my first yoga class in 2017 with no idea of what to expect. All I knew is that something was missing from my life whether it was movement, fitness, focus, mindfulness or more. I truly feel the positive change in my physical health and mental health. It was a drive for change in my life and honestly because my mom invited me and motivated me to join yoga. I quickly realized that yoga was something I wanted to do again. Along with yoga, I do meditations and breathing exercises everyday which has been my daily routine to start a day. I appreciated the combination of the strength and the balance of stretching and relaxing in my body. I started eating a healthy diet, green vegetables, stopped eating meat and less junk foods which really felt good for my body. Yoga has played an important role in my physical and spiritual well-being. It has helped me through the ups and the downs of my life, the stress of college, the intensity of my eating disorder and my recovery and rediscovery of a more balanced lifestyle. I’d like to encourage everybody, of every body type to find a practice that works for them! We all have different reasons for starting yoga, often it is to find better work/life balance, for more peace and ease in our mental health, to get in better shape and build more strength. Healthy life is all we need and we can achieve everything only if we are healthy and happy."
    },{
    "id": 3,
    "url": "/authors/parashagrawal1",
    "title": "Blockchain",
    "body": "Blockchain is an immutable digital ledger where all the transactions are public and transparent. Blockchain is decentralized and distributed that is linked to a P2P network. Bitcoin, Ethereum, NFTs, Collectibles are some implementations of blockchain. It can be used in different sectors such as crypto currency, banking, assets exchange, and many more. Blockchain can be used as a database as well. We can store data on blockchain for simple use cases where data can not be modified. For example: ownership of properties, hospital records and more. Nodes in the blockchain network store data generated by the blockchain and each node has the exact same copy of the data. Hence, it is decentralized and there is no chance for data loss. Firstly, a transaction is requested. Each transaction is stored in blocks after the transaction is verified. Node validates the transaction to be valid. Each block contains hash from the previous block and are linked in that way. This is also the reason it is called blockchain i.e. it is a chain of blocks connected to each others forming a chain. In every blockchain, node validates the transaction. For each validation, the validator node receives reward from the fee associated with the transaction. The transaction is validated by solving very complex cyrptographic algorithm. There are multiple consensus mechanism for selecting which node validates the transaction. The popular mechanisms are Proof of Work(Pow) and Proof of Stake(PoS). In PoW, multiple nodes work on solving the cyrptographic algorithm and compete against each other to validate the transaction to earn the rewards. In other words, transaction validation process in PoW is called mining. The validation process requires a lot of energy and the cost is very high. In PoS, node is chosen randomly by the blockchain. This consensus mechanism makes it more of cost and energy efficient. Nodes must stake some coins to be able to participate. The consensus mechanism is free from 51% attack in blockchain."
    },{
    "id": 4,
    "url": "/authors/poudelmadhav",
    "title": "How to add ssh and gpg keys in GitHub or GitLab?",
    "body": "Configure git Initial configuration of git if you have not set yet.  git config --global color.ui true  git config --global user.name &quot;YOUR NAME&quot;  git config --global user.email &quot;YOUR@EMAIL.com&quot;  ssh-keygen -t rsa -b 4096 -C &quot;YOUR@EMAIL.com&quot;  Adding SSH key Run this command in your terminal to generate new ssh key  ssh-keygen -t rsa -b 4096 -C &quot;YOUR@EMAIL.com&quot;  The next step is to take the newly generated SSH key and add it to your Github or GitLab account. You can add SSH key in your setting of GitLab or GitHub. You want to copy and paste the output of the following command and paste it in your ssh key setting.  cat ~/.ssh/id_rsa.pub  Once you've done this, you can check and see if it worked:  # For GitHub  ssh -T git@github.com  # OR for GitLab  ssh -T git@gitlab.com  You will get a message like this  # For GitHub  Hi &lt;your_usename&gt;! You've successfully authenticated, but GitHub does not provide shell access.  # OR for GitLab  Welcome to GitLab, @&lt;your_username&gt;!  Signing commits with GPG GitHub or GitLab can show whether a commit is verified or not when signed with a GPG key. All you need to do is upload the public GPG key in your profile settings. Generating a GPG key If you don’t already have a GPG key, the following steps will help you get started:  Install GPG for your operating system. If your Operating System has gpg2 installed, replace gpg with gpg2 in the following commands.  Generate the private/public key pair with the following command, which will spawn a series of questions:  gpg --full-gen-key  The first question is which algorithm can be used. Select the kind you want or press Enter to choose the default (RSA and RSA):  Please select what kind of key you want:  (1) RSA and RSA (default)  (2) DSA and Elgamal  (3) DSA (sign only)  (4) RSA (sign only)  Your selection? 1  The next question is key length. We recommend to choose the highest value which is 4096:  RSA keys may be between 1024 and 4096 bits long.  What keysize do you want? (2048) 4096  Requested keysize is 4096 bits  Next, you need to specify the validity period of your key. This is something subjective, and you can use the default value which is to never expire:  Please specify how long the key should be valid. 0 = key does not expire &lt;n&gt; = key expires in n days &lt;n&gt;w = key expires in n weeks &lt;n&gt;m = key expires in n months &lt;n&gt;y = key expires in n years Key is valid for? (0) 0  Key does not expire at all  Confirm that the answers you gave were correct by typing y:  Is this correct? (y/N) y  Enter you real name, the email address to be associated with this key (should match a verified email address you use in GitLab) and an optional comment (press Enter to skip):  GnuPG needs to construct a user ID to identify your key.  Real name: Mr. Robot  Email address: &lt;your_email Comment:  You selected this USER-ID: &quot;Mr. Robot &lt;your_email&gt;&quot; Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O  Pick a strong password when asked and type it twice to confirm.  Use the following command to list the private GPG key you just created:  gpg --list-secret-keys --keyid-format LONG &lt;your_email&gt;  Replace &lt;your_email&gt; with the email address you entered above.  Copy the GPG key ID that starts with sec. In the following example, that’s 30F2B65B9246B6CA:  sec rsa4096/30F2B65B9246B6CA 2017-08-18 [SC] D5E4F29F3275DC0CDA8FFC8730F2B65B9246B6CA uid [ultimate] Mr. Robot &lt;your_email&gt;  ssb rsa4096/B7ABC0813E4028C0 2017-08-18 [E]  Export the public key of that ID (replace your key ID from the previous step):  gpg --armor --export 30F2B65B9246B6CA  Finally, copy the public key and add it in your profile settings  Associating your GPG key with Git After you have created your GPG key and added it to your account, it’s time to tell Git which key to use.  Use the following command to list the private GPG key you just created:  gpg --list-secret-keys --keyid-format LONG &lt;your_email&gt;  Replace &lt;your_email&gt; with the email address you entered above.  Copy the GPG key ID that starts with sec. In the following example, that’s 30F2B65B9246B6CA:  sec rsa4096/30F2B65B9246B6CA 2017-08-18 [SC] D5E4F29F3275DC0CDA8FFC8730F2B65B9246B6CA uid [ultimate] Mr. Robot &lt;your_email&gt;  ssb rsa4096/B7ABC0813E4028C0 2017-08-18 [E]  Tell Git to use that key to sign the commits:  git config --global user.signingkey 30F2B65B9246B6CA  Replace 30F2B65B9246B6CA with your GPG key ID. Signing commits After you have created your GPG key and added it to your account, you can start signing your commits:  Commit like you used to, the only difference is the addition of the -S flag:  git commit -S -m &quot;My commit msg&quot;  Enter the passphrase of your GPG key when asked.  Push to GitLab and check that your commits are verified.  If you don’t want to type the -S flag every time you commit, you can tell Git to sign your commits automatically:  git config --global commit.gpgsign true  Verifying commits Within a project or merge request, navigate to the Commits tab. Signed commits will show a badge containing either “Verified” or “Unverified”, depending on the verification status of the GPG signature.  Referece Links  GitHub Docs  GoRails  Madhav Paudel's Blog"
    },{
    "id": 5,
    "url": "/authors/aadeshshrestha2",
    "title": "Building blogs using Trello as your database",
    "body": "Github has always been able to serve static contents through Jekyll using Github pages. Github pages has enabled millions of static pages to be published easily and for free. The only downside of it has been that Github supports limited number of Ruby gems. With the introduction of Github action, we can now run linux on Github and build jekyll sites or any other to create a blog. Using Trello as content management tool, we can integrate Trello with Jekyll to generate blog for free. Trello cards are easy to create as well as edit them as required. Example: Github workflow for creating blog with Github action.  name: Build blogs from Trello Card  on: push: branches: - gh-pages schedule: - cron: &quot;* */24 * * *&quot; workflow_dispatch:  jobs: build-and-deploy: name: Build and commit on same branch runs-on: ubuntu-latest steps: - name: Checkout source code uses: actions/checkout@v2  - name: create .env file run: echo &quot;${{ secrets.DOT_ENV }}&quot; &gt; .env  - name: Setup ruby run: echo &quot;::set-output name=RUBY_VERSION::$(cat .ruby-version)&quot; id: rbenv  - name: Use Ruby ${{ steps.rbenv.outputs.RUBY_VERSION }} uses: ruby/setup-ruby@v1  - name: Use cache gems uses: actions/cache@v1 with: path: vendor/bundle key: ${{ runner.os }}-gem-${{ hashFiles('**/Gemfile.lock') }} restore-keys: | ${{ runner.os }}-gem- - name: bundle install run: | gem install bundler bundle install --jobs 4 --retry 3 --path vendor/bundle  - name: rm posts run: | cp ./scripts/rmposts.sh _posts/rmposts.sh chmod +x _posts/rmposts.sh cd _posts sh rmposts.sh rm rmposts.sh cd .. - name: Build posts run: | bundle exec jekyll build - uses: EndBug/add-and-commit@v9 with: add: &quot;*.md&quot; author_name: autobot message: &quot;auto commit&quot;"
    },{
    "id": 6,
    "url": "/authors/sandeshshrestha17",
    "title": "Depth Mask",
    "body": "A depth mask provides the depth information from an image. The pixel intensity of the depth mask represents the object's distance from a viewpoint that can be color-coded to visually represent close or far objects. To display the depth map, we scale its values to [0,255] where 255 (white) pixel represents the farthest possible depth value and 0 (black) represents the closest potential depth value. Depth masks are often produced by stereo cameras and monocular cameras such as Microsoft Kinect."
    },{
    "id": 7,
    "url": "/authors/parashagrawal1",
    "title": "Integrating python script to ruby code",
    "body": "Introduction Ruby is a dynamic and open source language capable of carrying out large varieties of tasks and functionalities. But, there are few things that are limited to a specific language. There are scenarios where carrying out tasks in other programming language has more incentives. These incentives may be speed, convenience, better support, large community and many more. In this blog, we are going to discuss about a problem that is not generic but may be the only way out when in need. We are going to take a look at how to make a ruby script communicate with a python script and fetch response. It is going to be similar to sending a request into an endpoint and receiving response from it. A gem Open3 gives us ability to access stdin, stdout, and stderr when running other programs. We can install the gem simply by gem install open3. Ruby code  Lets create a ruby file named hello-ruby.rb  Firstly, require open3 in the file by simply writing require 'open3'  Then, we can use the Open3.capture3 method  Open3.capture3 gives a string for stdin; get strings for stdout, stderr We should pass the path to python  Example: /usr/bin/python for ubuntu  Then, the second argument should be the path to the python script There are no more mandatory arguments to be passed. But we can pass as much arguments as we require. These are received in the python file. Only strings can be passed as arguments.  The Open3.capture3 will return stdout, stderr and status from the call  The final ruby code should look like:  stdout, stderr, status = Open3.capture3( '/opt/venv/bin/python', './hello-python-script.py', 'this is a string_parameter required in the python file', 'in_case, we_require_an_array_to_be_passed, convert_it_to, comma_separated, string_format', '244' )  Python code Now, lets create a python file to receive the call and then respond as per required.  Create a python file named hello-python-script.py  Import sys in the file like import sys  Now, we can receive the arguments passed from the Open3 call using sys.argv  To get 'this is a string_parameter required in the python file', use sys.argv[1] since it will receive './hello-python-script.py' in the first index Similarly, we can get the comma separated string using sys.argv[2] and break it into required format In the same way, we receive '244' in sys.argv[3]  Do the required stuffs in python code  Now, we can simply send a response using sys.stdout.write(&quot;some-string&quot;)  We can respond json data like json.dumps(array_data)  The final code should look like: import sys  sentence_arg = sys.argv[1] comman_separated_arg = sys.argv[2] number_arg = sys.argv[3]  sys.stdout.write(number_arg)  Notes  The reponse number_arg is recevied as stdout value in ruby code  In case of error, the full error message is recevied as stderr  status receives the status from the call. In case of successful call, we can check using status.success  Simply run ruby hello-ruby.rb in command line  Example: The following code receives data from dummyjson. We pass arguments from the ruby code into python script and return response. Product list is printed in the console if the response is successful, else print error message.  // main.rb  require 'open3'  require 'json'  search_keyword = 'Laptop'  results_limit = 3  stdout, stderr, status = Open3.capture3( '/usr/bin/python3', './fetch-dummy-json.py', search_keyword, results_limit.to_s )  if status.success? puts JSON.parse(stdout) else puts stderr end  // fetch-dummy-json.py  import json  import requests  import sys  search_keyword = sys.argv[1]  results_limit = sys.argv[2]  payload={}  headers = {}  url = &quot;https://dummyjson.com/products/search?q=&quot; + search_keyword + &quot;&amp;limit=&quot; + results_limit  response = requests.request(&quot;GET&quot;, url, headers=headers, data=payload)  sys.stdout.write(json.dumps(response.text))"
    },{
    "id": 8,
    "url": "/authors/parashagrawal1",
    "title": "Smart Contracts",
    "body": "Smart contracts are programs stored on blockchain. They are equivalent to classes in other programming languages. Smart contracts are created for specific purposes in order to fulfill predetermined conditions. The main purpose of a smart contract is to implement and automate real world use cases. As in real world, contracts are pre determined conditions to be met by the signers, smart contracts are a set of promises, specified in digital form, including protocols within which the parties perform on these promises. A smart contract is a special kind of program that encodes business logic that runs on a special-purpose virtual machine baked into a blockchain or other type of distributed ledger. Smart contracts have the following characteristics:  They’re self-verifying due to automated possibilities.  They’re self-enforcing when the rules are met at all stages.  They’re tamper-proof, as no one can change what’s been programmed.  Smart contracts can:  automate processes done manually,  ensure security,  reduce relation to trusted intermediaries,  support multi-signature accounts to distribute funds as soon as all parties involved confirm the agreement,  manage users’ agreements,  provide utility to other contracts (similar to how a software library works),  store information about an app (domain registration information, membership records, etc.)."
    },{
    "id": 9,
    "url": "/authors/parashagrawal1",
    "title": "Building a simple NFT minting project",
    "body": "NFTs (Non-fungible Tokens) are crypto assets which are unique to each other. Digital assets, art and collectibles are it's major components. NFT standard is defined as ERC721 in ethereum network. No two NFTs are the same unlike 2 coins of the same crypto currency. Example: 2 bitcoins have the same value and inter changeable with each other. But two NFTs (e.g: cryptokitties) are not the same and do not have equal value. Openzeppelin is a community standard for securing blockchain applications. It provides blueprint for developing decentralized applications as mentioned in the ERC standards. So, we will be importing the required openzeppelin files directly from github. We will need to import ERC721URIStorage. We will store a JSON content IPFS URL as the tokenURI associated with token IDs. Other ERC721 methods are imported inside the ERC721URIStorage file. At First, we go to remix IDE which is an online web IDE for ethereum development. Then, we can create a new file inside the contracts folder. The filename extension must be .sol. We import required the openzeppelin standards in the newly created file  import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol&quot;;  import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721URIStorage.sol&quot;;  Then, we write down a simple contract structure extending the ERC721URIStorage Below is the code to implement a simple NFT minting project.  import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol&quot;;  import &quot;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721URIStorage.sol&quot;;  contract MyNFTProject is ERC721URIStorage { uint private tokenIds = 1;  constructor( string memory _name, string memory _symbol ) ERC721(_name, _symbol) { }  function mintToken(string memory tokenURI) external { tokenIds++; uint256 newItemId = tokenIds - 1; _safeMint(msg.sender, newItemId); _setTokenURI(newItemId, tokenURI); } }"
    },{
    "id": 10,
    "url": "/authors/parashagrawal1",
    "title": "Deploying smart contract in testnet",
    "body": "Testnet is an instance of a blockchain underlying the same or newer version of the actual network. As it's name suggests, testnet is used for deploying and testing smart contracts before deploying them to actual network. For example: Goerli testnet can be used as testnet before deploying to the ethereum network. The entire purpose of testnet is to create a free testing environment for developers. We will require few ether for deploying any smart contract. For that, we can go to the respective faucet to get some test ether. In our case, we will visit the goerli faucet and get some ether. In our hardhat.config.js, we can add the following code. Do not forget to add GOERLI_ALCHEMY_KEY and GOERLI_ACCOUNT_PRIVATE_KEY to the .env file.  goerli: { url: `https://eth-goerli.g.alchemy.com/v2/${process.env.GOERLI_ALCHEMY_KEY}`, gas: 2100000, gasPrice: 8000000000, accounts: [process.env.GOERLI_ACCOUNT_PRIVATE_KEY] },  We will need to write a migration as below. Replace Contract with your actual contract name.  // 1_deploy_contract.js  async function main() { const ContractFactory = await ethers.getContractFactory('Contract'); const Contract = await ContractFactory.deploy('Contract', 'Collectible', marketplaceAddress); await Contract.deployed();  console.log(`Collectible contract address: ${Contract.address}`) }  main() .then(() =&gt; process.exit(0)) .catch(err =&gt; { console.log(err); });  Run the script in console by writing npx hardhat run ./scripts/1_deploy_contract.js --network goerli. The deployed contract address should appear in the console itself."
    },{
    "id": 11,
    "url": "/authors/parashagrawal1",
    "title": "Signing and verifying data on blockchain",
    "body": "A digital signature is a mathematical algorithm routinely used to validate the authenticity and integrity of a message. Digital signature includes the concept of public and private keys. Generally, a message hash is signed by an address, then the signed message is transacted on behalf of the user by someone else. The real use case of digital signature in blockchain is to verify if the transaction was authroized by the user or not. In blockchain, we use ECDSA algorithm to sign a message (data in our case). A set of data is prepared in the frontend. The data is then converted to hash using web3-utils like below. We pass all the values to hash in the soliditySha3 method.  const { soliditySha3 } = require(&quot;web3-utils&quot;);  let hashedMessage = web3.utils.soliditySha3( 4, 7, 1 )  We will then receive some hash like 0x597f5f99524e9dfde89054758e759ecaea48dffb5d1d2e944e7ddedc03edd085. The signer is supposed to sign the hash that we receive. In case, we need to pass string, we will have to convert the string to bytes like web3.utils.soliditySha3(str).substring(0, 10). We prefer to use bytes in solidity rather than string due to some drawbacks like we can not compare two strings to each other. The full code should look like:  const { soliditySha3 } = require(&quot;web3-utils&quot;);  let hashedMessage = web3.utils.soliditySha3( 4, 7, web3.utils.soliditySha3(&quot;Hello&quot;) )  We ask the user for signature using metamask with the use of web3.eth.personal.sign(hashedMessage, signer_address); method. This will complete the signature process in the frontend which will give us the signedMessage. Now, we will be looking at how to verify the signature. Firstly, we will pass the hashedMessage and signedMessage in a method in solidity. There is a library ECDSAUpgradeable by openzeppelin which has a recoverSigner method. This method will return the signer address when we pass hashedMessage and signedMessage in it. Example: ECDSAUpgradeable.recover(hashedMessage, signedMessage). We can finally compare the original signer address and the returned signer from recover method. If both the addresses match, the signer has signed the message and vice versa. For futher security, we can pass the original message to solidity and hash it there. In solidity, we can hash the message like  bytes32 hashedMessage = keccak256(abi.encodePacked(param1, param2, param3))  bytes32 ethHashedMessage = keccak256(abi.encodePacked(&quot;x19Ethereum Signed Message:n32&quot;, hashedMessage))  The second part of eth hashing is done automatically by soliditySha3 in the frontend. Then, continue using ECDSAUpgradeable.recover and the comparision logic."
    },]
</script>


      </header>
      <main class="main-body" id="main" >
        <div class="row">
          <div class="sidebar">
          <div class="sidebar_container">
  <div class="brand">
    <a href="/"><img src="https://freesvg.org/img/Paper-note.png" alt="Brand Image" class="logo"></a>
    <h4>Today I Learned</h4>
  </div>
  <div>
    <h4>Authors</h4>
    <ul>
      
        <li class="sidebar_list"><a href="/authors/poudelmadhav">Madhav</a><span>2</span></li>
      
        <li class="sidebar_list"><a href="/authors/salinadangol2">Salina</a><span>2</span></li>
      
        <li class="sidebar_list"><a href="/authors/parashagrawal1">Parash</a><span>6</span></li>
      
        <li class="sidebar_list"><a href="/authors/aadeshshrestha2">Aadesh</a><span>1</span></li>
      
        <li class="sidebar_list"><a href="/authors/sandeshshrestha17">Sandesh</a><span>1</span></li>
      
    </ul>

    <h4>Tags</h4>
    <ul>
      
        <li class="sidebar_list"> <a href="/labels/random">Random</a><span>2</span></li>
      
        <li class="sidebar_list"> <a href="/labels/qa">Qa</a><span>1</span></li>
      
        <li class="sidebar_list"> <a href="/labels/Blockchain">Blockchain</a><span>5</span></li>
      
        <li class="sidebar_list"> <a href="/labels/devops">Devops</a><span>1</span></li>
      
        <li class="sidebar_list"> <a href="/labels/backend">Backend</a><span>2</span></li>
      
        <li class="sidebar_list"> <a href="/labels/ml">Ml</a><span>1</span></li>
      
    </ul>
  </div>
  <div>
    <section id="footer">
      <ul class="icons">
        <li><a href="https://www.facebook.com/chulo.solutions/" class="fa-brands fa-square-facebook" target="_blank"></a></li>
        <li><a href="https://www.instagram.com/chulosolutions/" class="fa-brands fa-instagram" target="_blank"></a></li>
        <li><a href="https://www.linkedin.com/company/chulo-solution/" class="fa-brands fa-linkedin" target="_blank"></a></li>
        <li><a href="mailto:contact@chulo-solutions.com" class="fa-solid fa-envelope"></a></li>
      </ul>
      <p class="copyright">&copy;  <a href="http://namespace.jp" target="_blank">Chulo Solutions </a><br> 2016 - <span id="copyright-year"></span></a>.</p>
    </section>
  </div>
</div>
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
      
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/dark.min.css" integrity="sha512-bfLTSZK4qMP/TWeS1XJAR/VDX0Uhe84nN5YmpKk5x8lMkV0D+LwbuxaJMYTPIV13FzEv4CUOhHoc+xZBDgG9QA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

          </div>
          <div class="main_content" id="contentArea">
            
  <article class="post">
    <div class="title">
      <h2>
        Deploying smart contract in testnet
      </h2>
      <!-- <p>Lorem ipsum dolor amet nullam consequat etiam feugiat</p> -->
    </div>
    <div class="meta">
      <small>
        <i class="fa-solid fa-pen-nib"></i>
      </small>
      <a href="#" class="author">
        <small class="name">Parash Agrawal</small>
        <!-- <img src="/images/avatar.jpg" alt="" /> -->
      </a>
      <small>
        <i class="fa-regular fa-calendar"></i>
      </small>
  
        <small>Fri Mar 10 2023 </small>
    </div>
    <span class="image featured">
      <img src="images/pic01.jpg" alt="" />
    </span>
    <p><p>Testnet is an instance of a blockchain underlying the same or newer version of
the actual network. As it's name suggests, testnet is used for deploying and
testing smart contracts before deploying them to actual network. For example:
Goerli testnet can be used as testnet before deploying to the ethereum network.
The entire purpose of testnet is to create a free testing environment for
developers.</p>
<p>We will require few ether for deploying any smart contract. For that, we can go
to the respective faucet to get some test ether. In our case, we will visit the
<a href="https://goerlifaucet.com/">goerli faucet</a> and get some ether.</p>
<p>In our <code>hardhat.config.js</code>, we can add the following code. Do not forget to add
<code>GOERLI_ALCHEMY_KEY</code> and <code>GOERLI_ACCOUNT_PRIVATE_KEY</code> to the <code>.env</code> file.</p>
<pre><code class="language-js">
goerli: {
  url: `https://eth-goerli.g.alchemy.com/v2/${process.env.GOERLI_ALCHEMY_KEY}`,
  gas: 2100000,
  gasPrice: 8000000000,
  accounts: [process.env.GOERLI_ACCOUNT_PRIVATE_KEY]
},

</code></pre>
<p>We will need to write a migration as below. Replace <code>Contract</code> with your actual
contract name.</p>
<pre><code class="language-sol">
// 1_deploy_contract.js

async function main() {
  const ContractFactory = await ethers.getContractFactory('Contract');
  const Contract = await ContractFactory.deploy('Contract', 'Collectible', marketplaceAddress);
  await Contract.deployed();

  console.log(`Collectible contract address: ${Contract.address}`)
}


main()
  .then(() =&gt; process.exit(0))
  .catch(err =&gt; {
    console.log(err);
  });
</code></pre>
<p>Run the script in console by writing <code>npx hardhat run ./scripts/1_deploy_contract.js --network goerli</code>.</p>
<p>The deployed contract address should appear in the console itself.</p>
</p>



    <div></div>
  </article>

          </div>
        </div>
      </main> 
    <footer>
      <script src="/assets/js/jquery.min.js"></script>



<script src="/assets/js/lunr.min.js"></script>
<script src="/assets/js/main.js"></script>
<script src="/assets/js/search.js"></script>

    </footer>
  </body>
</body>
</html>
